Native Modules
Your React Native application code may need to interact with native platform APIs that aren't provided by React Native or an existing library. You can write the integration code yourself using a Turbo Native Module. This guide will show you how to write one.
The basic steps are:
1.	define a typed JavaScript specification using one of the most popular JavaScript type annotation languages: Flow or TypeScript;
2.	configure your dependency management system to run Codegen, which converts the specification into native language interfaces;
3.	write your application code using your specification; and
4.	write your native platform code using the generated interfaces to write and hook your native code into the React Native runtime environment.
Lets work through each of these steps by building an example Turbo Native Module. The rest of this guide assume that you have created your application running the command:
shell
npx @react-native-community/cli@latest init TurboModuleExample --version 0.76.0

Native Persistent Storage
This guide will show you how to write an implementation of the Web Storage API: localStorage. The API is relatable to a React developer who might be writing application code on your project.
To make this work on mobile, we need to use Android and iOS APIs:
•	Android: SharedPreferences, and
•	iOS: NSUserDefaults.
1. Declare Typed Specification
React Native provides a tool called Codegen, which takes a specification written in TypeScript or Flow and generates platform specific code for Android and iOS. The specification declares the methods and data types that will pass back and forth between your native code and the React Native JavaScript runtime. A Turbo Native Module is both your specification, the native code you write, and the Codegen interfaces generated from your specification.
To create a specs file:
1.	Inside the root folder of your app, create a new folder called specs.
2.	Create a new file called NativeLocalStorage.ts.
info
You can see all of the types you can use in your specification and the native types that are generated in the Appendix documentation.
Here is an implementation of the localStorage specification:
specs/NativeLocalStorage.ts
import type {TurboModule} from 'react-native';
import {TurboModuleRegistry} from 'react-native';

export interface Spec extends TurboModule {
  setItem(value: string, key: string): void;
  getItem(key: string): string | null;
  removeItem(key: string): void;
  clear(): void;
}

export default TurboModuleRegistry.getEnforcing<Spec>(
  'NativeLocalStorage',
);

2. Configure Codegen to run
The specification is used by the React Native Codegen tools to generate platform specific interfaces and boilerplate for us. To do this, Codegen needs to know where to find our specification and what to do with it. Update your package.json to include:
package.json
     "start": "react-native start",
     "test": "jest"
   },
   "codegenConfig": {
     "name": "NativeLocalStorageSpec",
     "type": "modules",
     "jsSrcsDir": "specs",
     "android": {
       "javaPackageName": "com.nativelocalstorage"
     }
   },
   "dependencies": {

With everything wired up for Codegen, we need to prepare our native code to hook into our generated code.
Codegen is executed through the generateCodegenArtifactsFromSchema Gradle task:
bash
cd android
./gradlew generateCodegenArtifactsFromSchema

BUILD SUCCESSFUL in 837ms
14 actionable tasks: 3 executed, 11 up-to-date

This is automatically run when you build your Android application.
3. Write Application Code using the Turbo Native Module
Using NativeLocalStorage, here’s a modified App.tsx that includes some text we want persisted, an input field and some buttons to update this value.
The TurboModuleRegistry supports 2 modes of retrieving a Turbo Native Module:
•	get<T>(name: string): T | null which will return null if the Turbo Native Module is unavailable.
•	getEnforcing<T>(name: string): T which will throw an exception if the Turbo Native Module is unavailable. This assumes the module is always available.
App.tsx
import React from 'react';
import {
  SafeAreaView,
  StyleSheet,
  Text,
  TextInput,
  Button,
} from 'react-native';

import NativeLocalStorage from './specs/NativeLocalStorage';

const EMPTY = '<empty>';

function App(): React.JSX.Element {
  const [value, setValue] = React.useState<string | null>(null);

  const [editingValue, setEditingValue] = React.useState<
    string | null
  >(null);

  React.useEffect(() => {
    const storedValue = NativeLocalStorage?.getItem('myKey');
    setValue(storedValue ?? '');
  }, []);

  function saveValue() {
    NativeLocalStorage?.setItem(editingValue ?? EMPTY, 'myKey');
    setValue(editingValue);
  }

  function clearAll() {
    NativeLocalStorage?.clear();
    setValue('');
  }

  function deleteValue() {
    NativeLocalStorage?.removeItem('myKey');
    setValue('');
  }

  return (
    <SafeAreaView style={{flex: 1}}>
      <Text style={styles.text}>
        Current stored value is: {value ?? 'No Value'}
      </Text>
      <TextInput
        placeholder="Enter the text you want to store"
        style={styles.textInput}
        onChangeText={setEditingValue}
      />
      <Button title="Save" onPress={saveValue} />
      <Button title="Delete" onPress={deleteValue} />
      <Button title="Clear" onPress={clearAll} />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  text: {
    margin: 10,
    fontSize: 20,
  },
  textInput: {
    margin: 10,
    height: 40,
    borderColor: 'black',
    borderWidth: 1,
    paddingLeft: 5,
    paddingRight: 5,
    borderRadius: 5,
  },
});

export default App;

4. Write your Native Platform code
With everything prepared, we're going to start writing native platform code. We do this in 2 parts:
note
This guide shows you how to create a Turbo Native Module that only works with the New Architecture. If you need to support both the New Architecture and the Legacy Architecture, please refer to our backwards compatibility guide.
Now it's time to write some Android platform code to make sure localStorage survives after the application is closed.
The first step is to implement the generated NativeLocalStorageSpec interface:
android/app/src/main/java/com/nativelocalstorage/NativeLocalStorageModule.java
package com.nativelocalstorage;

import android.content.Context;
import android.content.SharedPreferences;
import com.nativelocalstorage.NativeLocalStorageSpec;
import com.facebook.react.bridge.ReactApplicationContext;

public class NativeLocalStorageModule extends NativeLocalStorageSpec {

  public static final String NAME = "NativeLocalStorage";

  public NativeLocalStorageModule(ReactApplicationContext reactContext) {
    super(reactContext);
  }

  @Override
  public String getName() {
    return NAME;
  }

  @Override
  public void setItem(String value, String key) {
    SharedPreferences sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE);
    SharedPreferences.Editor editor = sharedPref.edit();
    editor.putString(key, value);
    editor.apply();
  }

  @Override
  public String getItem(String key) {
    SharedPreferences sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE);
    String username = sharedPref.getString(key, null);
    return username;
  }

  @Override
  public void removeItem(String key) {
    SharedPreferences sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE);
    sharedPref.edit().remove(key).apply();
  }
}

Next we need to create NativeLocalStoragePackage. It provides an object to register our Module in the React Native runtime, by wrapping it as a Base Native Package:
android/app/src/main/java/com/nativelocalstorage/NativeLocalStoragePackage.java
package com.nativelocalstorage;

import com.facebook.react.BaseReactPackage;
import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.module.model.ReactModuleInfo;
import com.facebook.react.module.model.ReactModuleInfoProvider;

import java.util.HashMap;
import java.util.Map;

public class NativeLocalStoragePackage extends BaseReactPackage {

  @Override
  public NativeModule getModule(String name, ReactApplicationContext reactContext) {
    if (name.equals(NativeLocalStorageModule.NAME)) {
      return new NativeLocalStorageModule(reactContext);
    } else {
      return null;
    }
  }

  @Override
  public ReactModuleInfoProvider getReactModuleInfoProvider() {
    return new ReactModuleInfoProvider() {
      @Override
      public Map<String, ReactModuleInfo> getReactModuleInfos() {
        Map<String, ReactModuleInfo> map = new HashMap<>();
        map.put(NativeLocalStorageModule.NAME, new ReactModuleInfo(
          NativeLocalStorageModule.NAME,       // name
          NativeLocalStorageModule.NAME,       // className
          false, // canOverrideExistingModule
          false, // needsEagerInit
          false, // isCXXModule
          true   // isTurboModule
        ));
        return map;
      }
    };
  }
}

Finally, we need to tell the React Native in our main application how to find this Package. We call this "registering" the package in React Native.
In this case, you add it to be returned by the getPackages method.
info
Later you’ll learn how to distribute your Native Modules as npm packages, which our build tooling will autolink for you.
android/app/src/main/java/com/turobmoduleexample/MainApplication.java
package com.inappmodule;

import android.app.Application;
import com.facebook.react.PackageList;
import com.facebook.react.ReactApplication;
import com.facebook.react.ReactHost;
import com.facebook.react.ReactNativeHost;
import com.facebook.react.ReactPackage;
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;
import com.facebook.react.defaults.DefaultReactHost;
import com.facebook.react.defaults.DefaultReactNativeHost;
import com.facebook.soloader.SoLoader;
import com.nativelocalstorage.NativeLocalStoragePackage;

import java.util.ArrayList;
import java.util.List;

public class MainApplication extends Application implements ReactApplication {

  private final ReactNativeHost reactNativeHost = new DefaultReactNativeHost(this) {
    @Override
    public List<ReactPackage> getPackages() {
      List<ReactPackage> packages = new PackageList(this).getPackages();
      // Packages that cannot be autolinked yet can be added manually here, for example:
      // packages.add(new MyReactNativePackage());
      packages.add(new NativeLocalStoragePackage());
      return packages;
    }

    @Override
    public String getJSMainModuleName() {
      return "index";
    }

    @Override
    public boolean getUseDeveloperSupport() {
      return BuildConfig.DEBUG;
    }

    @Override
    public boolean isNewArchEnabled() {
      return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;
    }

    @Override
    public boolean isHermesEnabled() {
      return BuildConfig.IS_HERMES_ENABLED;
    }
  };

  @Override
  public ReactHost getReactHost() {
    return DefaultReactHost.getDefaultReactHost(getApplicationContext(), reactNativeHost);
  }

  @Override
  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, false);
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      DefaultNewArchitectureEntryPoint.load();
    }
  }
}

You can now build and run your code on an emulator:
bash
yarn run android
Cross-Platform Native Modules (C++)
Writing a module in C++ is the best way to share platform-agnostic code between Android and iOS. With pure C++ modules, you can write your logic only once and reuse it right away from all the platforms, without the need of writing platform-specific code.
In this guide, we will go through the creation of a pure C++ Turbo Native Module:
1.	Create the JS specs
2.	Configure Codegen to generate the scaffolding
3.	Implement the Native logic
4.	Register the module in the Android and iOS application
5.	Test your changes in JS
The rest of this guide assume that you have created your application running the command:
shell
npx @react-native-community/cli@latest init SampleApp --version 0.80.0

1. Create the JS specs
Pure C++ Turbo Native Modules are Turbo Native Modules. They need a specification file (also called spec file) so that Codegen can create the scaffolding code for us. The specification file is also what we use to access the Turbo Native Module in JS.
Spec files need to be written in a typed JS dialect. React Native currently supports Flow or TypeScript.
1.	Inside the root folder of your app, create a new folder called specs.
2.	Create a new file called NativeSampleModule.ts with the following code:
warning
All Native Turbo Module spec files must have the prefix Native, otherwise Codegen will ignore them.
specs/NativeSampleModule.ts
import {TurboModule, TurboModuleRegistry} from 'react-native';

export interface Spec extends TurboModule {
  readonly reverseString: (input: string) => string;
}

export default TurboModuleRegistry.getEnforcing<Spec>(
  'NativeSampleModule',
);

2. Configure Codegen
The next step is to configure Codegen in your package.json. Update the file to include:
package.json
     "start": "react-native start",
     "test": "jest"
   },
   "codegenConfig": {
     "name": "AppSpecs",
     "type": "modules",
     "jsSrcsDir": "specs",
     "android": {
       "javaPackageName": "com.sampleapp.specs"
     }
   },
   "dependencies": {

This configuration tells Codegen to look for spec files in the specs folder. It also instructs Codegen to only generate code for modules and to namespace the generated code as AppSpecs.
3. Write the Native Code
Writing a C++ Turbo Native Module allows you to share the code between Android an iOS. Therefore we will be writing the code once, and we will look into what changes we need to apply to the platforms so that the C++ code can be picked up.
1.	Create a folder named shared at the same level as the android and ios folders.
2.	Inside the shared folder, create a new file called NativeSampleModule.h.
shared/NativeSampleModule.h
#pragma once

#include <AppSpecsJSI.h>

#include <memory>
#include <string>

namespace facebook::react {

class NativeSampleModule : public NativeSampleModuleCxxSpec<NativeSampleModule> {
public:
  NativeSampleModule(std::shared_ptr<CallInvoker> jsInvoker);

  std::string reverseString(jsi::Runtime& rt, std::string input);
};

} // namespace facebook::react


3.	Inside the shared folder, create a new file called NativeSampleModule.cpp.
shared/NativeSampleModule.cpp
#include "NativeSampleModule.h"

namespace facebook::react {

NativeSampleModule::NativeSampleModule(std::shared_ptr<CallInvoker> jsInvoker)
    : NativeSampleModuleCxxSpec(std::move(jsInvoker)) {}

std::string NativeSampleModule::reverseString(jsi::Runtime& rt, std::string input) {
  return std::string(input.rbegin(), input.rend());
}

} // namespace facebook::react

Let's have a look at the two files we created:
•	The NativeSampleModule.h file is the header file for a Pure C++ TurboModule. The include statements make sure that we include the specs that will be created by Codegen and that contains the interface and the base class we need to implement.
•	The module lives in the facebook::react namespace to have access to all the types that live in that namespace.
•	The class NativeSampleModule is the actual Turbo Native Module class and it extends the NativeSampleModuleCxxSpec class which contains some glue code and boilerplate code to let this class behave as a Turbo Native Module.
•	Finally, we have the constructor, that accepts a pointer to the CallInvoker, to communicate with JS if needed and the function's prototype we have to implement.
The NativeSampleModule.cpp file is the actual implementation of our Turbo Native Module and implements the constructor and the method that we declared in the specs.
4. Register the Module in the platform
The next steps will let us register the module in the platform. This is the step that exposes the native code to JS so that the React Native application can finally call the native methods from the JS layer.
This is the only time when we will have to write some platform-specific code.
Android
To make sure that the Android app can effectively build the C++ Turbo Native Module, we need to:
1.	Create a CMakeLists.txt to access our C++ code.
2.	Modify build.gradle to point to the newly created CMakeLists.txt file.
3.	Create an OnLoad.cpp file in our Android app to register the new Turbo Native Module.
1. Create the CMakeLists.txt file
Android uses CMake to build. CMake needs to access the files we defined in our shared folder to be able to build them.
1.	Create a new folder SampleApp/android/app/src/main/jni. The jni folder is where the C++ side of Android lives.
2.	Create a CMakeLists.txt file and add this context:
CMakeLists.txt
cmake_minimum_required(VERSION 3.13)

# Define the library name here.
project(appmodules)

# This file includes all the necessary to let you build your React Native application
include(${REACT_ANDROID_DIR}/cmake-utils/ReactNative-application.cmake)

# Define where the additional source code lives. We need to crawl back the jni, main, src, app, android folders
target_sources(${CMAKE_PROJECT_NAME} PRIVATE ../../../../../shared/NativeSampleModule.cpp)

# Define where CMake can find the additional header files. We need to crawl back the jni, main, src, app, android folders
target_include_directories(${CMAKE_PROJECT_NAME} PUBLIC ../../../../../shared)

The CMake file does the following things:
•	Defines the appmodules library, where all the app C++ code will be included.
•	Loads the base React Native's CMake file.
•	Adds the Module C++ source code that we need to build with the target_sources directives. By default React Native will already populate the appmodules library with default sources, here we include our custom one. You can see that we need to crawl back from the jni folder to the shared folder where our C++ Turbo Module lives.
•	Specifies where CMake can find the module header files. Also in this case we need to crawl back from the jni folder.
2. Modify build.gradle to include the custom C++ code
Gradle is the tool that orchestrates the Android build. We need to tell it where it can find the CMake files to build the Turbo Native Module.
1.	Open the SampleApp/android/app/build.gradle file.
2.	Add the following block into the Gradle file, within the existent android block:
android/app/build.gradle
    buildTypes {
        debug {
            signingConfig signingConfigs.debug
        }
        release {
            // Caution! In production, you need to generate your own keystore file.
            // see https://reactnative.dev/docs/signed-apk-android.
            signingConfig signingConfigs.debug
            minifyEnabled enableProguardInReleaseBuilds
            proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
        }
    }

+   externalNativeBuild {
+       cmake {
+           path "src/main/jni/CMakeLists.txt"
+       }
+   }
}

This block tells the Gradle file where to look for the CMake file. The path is relative to the folder where the build.gradle file lives, so we need to add the path to the CMakeLists.txt files in the jni folder.
3. Register the new Turbo Native Module
The final step is to register the new C++ Turbo Native Module in the runtime, so that when JS requires the C++ Turbo Native Module, the app knows where to find it and can return it.
1.	From the folder SampleApp/android/app/src/main/jni, run the following command:
sh
curl -O https://raw.githubusercontent.com/facebook/react-native/v0.76.0/packages/react-native/ReactAndroid/cmake-utils/default-app-setup/OnLoad.cpp

2.	Then, modify this file as follows:
android/app/src/main/jni/OnLoad.cpp
#include <DefaultComponentsRegistry.h>
#include <DefaultTurboModuleManagerDelegate.h>
#include <autolinking.h>
#include <fbjni/fbjni.h>
#include <react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h>
#include <rncore.h>

+ // Include the NativeSampleModule header
+ #include <NativeSampleModule.h>

//...

std::shared_ptr<TurboModule> cxxModuleProvider(
    const std::string& name,
    const std::shared_ptr<CallInvoker>& jsInvoker) {
  // Here you can provide your CXX Turbo Modules coming from
  // either your application or from external libraries. The approach to follow
  // is similar to the following (for a module called `NativeCxxModuleExample`):
  //
  // if (name == NativeCxxModuleExample::kModuleName) {
  //   return std::make_shared<NativeCxxModuleExample>(jsInvoker);
  // }

+  // This code register the module so that when the JS side asks for it, the app can return it
+  if (name == NativeSampleModule::kModuleName) {
+    return std::make_shared<NativeSampleModule>(jsInvoker);
+  }

  // And we fallback to the CXX module providers autolinked
  return autolinking_cxxModuleProvider(name, jsInvoker);
}

// leave the rest of the file

These steps download the original OnLoad.cpp file from React Native, so that we can safely override it to load the C++ Turbo Native Module in the app.
Once we downloaded the file, we can modify it by:
•	Including the header file that points to our module
•	Registering the Turbo Native Module so that when JS requires it, the app can return it.
Now, you can run yarn android from the project root to see your app building successfully.
What is Codegen?
Codegen is a tool to avoid writing a lot of repetitive code. Using Codegen is not mandatory: you can write all the generated code manually. However, Codegen generates scaffolding code that could save you a lot of time.
React Native invokes Codegen automatically every time an iOS or Android app is built. Occasionally, you would like to manually run the Codegen scripts to know which types and files are actually generated: this is a common scenario when developing Turbo Native Modules and Fabric Native Components.
How Codegen Works
Codegen is a process that is tightly coupled with a React Native app. The Codegen scripts live inside the react-native NPM package and the apps call those scripts at build time.
Codegen crawls the folders in your project, starting from a directory you specify in your package.json, looking for some specific JS files that contain the specification (or specs) for your custom modules and components. Spec files are JS files written in a typed dialect: React Native currently supports Flow and TypeScript.
Every time Codegen finds a spec file, it generates boilerplate code associated with it. Codegen generates some C++ glue-code and then it generates platform-specific code, using Java for Android and Objective-C++ for iOS.


Using Codegen
This guide teaches how to:
•	Configure Codegen.
•	Invoke it manually for each platform.
It also describes the generated code.
Prerequisites
You always need a React Native app to generate the code properly, even when invoking the Codegen manually.
The Codegen process is tightly coupled with the build of the app, and the scripts are located in the react-native NPM package.
For the sake of this guide, create a project using the React Native CLI as follows:
bash
npx @react-native-community/cli@latest init SampleApp --version 0.76.0

Codegen is used to generate the glue-code for your custom modules or components. See the guides for Turbo Native Modules and Fabric Native Components for more details on how to create them.
Configuring Codegen
Codegen can be configured in your app by modifying the package.json file. Codegen is controlled by a custom field called codegenConfig.
package.json
  "codegenConfig": {
    "name": "<SpecName>",
    "type": "<types>",
    "jsSrcsDir": "<source_dir>",
    "android": {
      "javaPackageName": "<java.package.name>"
    },
    "ios": {
      "modules": {
        "TestModule": {
          "className": "<iOS-class-implementing-the-RCTModuleProvider-protocol>",
          "unstableRequiresMainQueueSetup": false,
          "conformsToProtocols": ["RCTImageURLLoader", "RCTURLRequestHandler", "RCTImageDataDecoder"],
        }
      },
      "components": {
        "TestComponent": {
          "className": "<iOS-class-implementing-the-component>"
        }
      }
    }
  },

You can add this snippet to your app and customize the various fields:
•	name: Name of the codegen config. This will customize the codegen output: the filenames, and the code.
•	type:
o	modules: Only generate code for modules.
o	components: Only generate code for components.
o	all: Generate code for everything.
•	jsSrcsDir: The root folder where all your specs live.
•	android: Codegen configuration for Android (all optional):
o	.javaPackageName: Configure the package name of the Android Java codegen output.
•	ios: Codegen configuration for iOS (all optional):
o	.modules[moduleName]:
	.className: This module's ObjC class. Or, if it's a C++-only module, its RCTModuleProvider class.
	.unstableRequiresMainQueueSetup: Initialize this module on the UI Thread, before running any JavaScript.
	.conformsToProtocols: Annotate which of these protocols this module conforms to any of the following protocols: RCTImageURLLoader, RCTURLRequestHandler, RCTImageDataDecoder.
o	.components[componentName]:
	.className: This component's ObjC class (e.g: TextInput -> RCTTextInput).
When Codegen runs, it searches among all the dependencies of the app, looking for JS files that respects some specific conventions, and it generates the required code:
•	Turbo Native Modules require that the spec files are prefixed with Native. For example, NativeLocalStorage.ts is a valid name for a spec file.
•	Native Fabric Components require that the spec files are suffixed with NativeComponent. For example, WebViewNativeComponent.ts is a valid name for a spec file.
Running Codegen
The rest of this guide assumes that you have a Native Turbo Module, a Native Fabric Component or both already set up in your project. We also assume that you have valid specification files in the jsSrcsDir specified in the package.json.
Android
Codegen for Android is integrated with the React Native Gradle Plugin (RNGP). The RNGP contains a task that can be invoked that reads the configurations defined in the package.json file and execute Codegen. To run the gradle task, first navigate inside the android folder of your project. Then run:
bash
./gradlew generateCodegenArtifactsFromSchema

This task invokes the generateCodegenArtifactsFromSchema command on all the imported projects of the app (the app and all the node modules which are linked to it). It generates the code in the corresponding node_modules/<dependency> folder. For example, if you have a Fabric Native Component whose Node module is called my-fabric-component, the generated code is located in the SampleApp/node_modules/my-fabric-component/android/build/generated/source/codegen path. For the app, the code is generated in the android/app/build/generated/source/codegen folder.
The Generated Code
After running the gradle command above, you will find the codegen code in the SampleApp/android/app/build folder. The structure will look like this:
build
└── generated
    └── source
        └── codegen
            ├── java
            │   └── com
            │       ├── facebook
            │       │   └── react
            │       │       └── viewmanagers
            │       │           ├── <nativeComponent>ManagerDelegate.java
            │       │           └── <nativeComponent>ManagerInterface.java
            │       └── sampleapp
            │           └── NativeLocalStorageSpec.java
            ├── jni
            │   ├── <codegenConfig.name>-generated.cpp
            │   ├── <codegenConfig.name>.h
            │   ├── CMakeLists.txt
            │   └── react
            │       └── renderer
            │           └── components
            │               └── <codegenConfig.name>
            │                   ├── <codegenConfig.name>JSI-generated.cpp
            │                   ├── <codegenConfig.name>.h
            │                   ├── ComponentDescriptors.cpp
            │                   ├── ComponentDescriptors.h
            │                   ├── EventEmitters.cpp
            │                   ├── EventEmitters.h
            │                   ├── Props.cpp
            │                   ├── Props.h
            │                   ├── ShadowNodes.cpp
            │                   ├── ShadowNodes.h
            │                   ├── States.cpp
            │                   └── States.h
            └── schema.json

The generated code is split in two folders:
•	java which contains the platform specific code
•	jni which contains the C++ code required to let JS and Java interact correctly.
In the java folder, you can find the Fabric Native component generated code in the com/facebook/viewmanagers subfolder.
•	the <nativeComponent>ManagerDelegate.java contains the methods that the ViewManager can call on the custom Native Component
•	the <nativeComponent>ManagerInterface.java contains the interface of the ViewManager.
In the folder whose name was set up in the codegenConfig.android.javaPackageName, instead, you can find the abstract class that a Turbo Native Module has to implement to carry out its tasks.
In the jni folder, finally, there is all the boilerplate code to connect JS to Android.
•	<codegenConfig.name>.h this contains the interface of your custom C++ Turbo Native Modules.
•	<codegenConfig.name>-generated.cpp this contains the glue code of your custom C++ Turbo Native Modules.
•	react/renderer/components/<codegenConfig.name>: this folder contains all the glue-code required by your custom component.
This structure has been generated by using the value all for the codegenConfig.type field. If you use the value modules, expect to see no react/renderer/components/ folder. If you use the value components, expect not to see any of the other files.


The Codegen CLI
Calling Gradle or manually calling a script might be hard to remember and it requires a lot of ceremony.
To simplify it, we created a CLI tool that can help you running those tasks: the Codegen cli. This command runs @react-native/codegen for your project. The following options are available:
sh
npx @react-native-community/cli codegen --help
Usage: rnc-cli codegen [options]

Options:
  --verbose            Increase logging verbosity
  --path <path>        Path to the React Native project root. (default: "/Users/MyUsername/projects/my-app")
  --platform <string>  Target platform. Supported values: "android", "ios", "all". (default: "all")
  --outputPath <path>  Path where generated artifacts will be output to.
  -h, --help           display help for command

Examples
•	Read package.json from the current working directory, generate code based on its codegenConfig.
shell
npx @react-native-community/cli codegen

•	Read package.json from the current working directory, generate iOS code in the location defined in the codegenConfig.
shell
npx @react-native-community/cli codegen --platform ios

•	Read package.json from third-party/some-library, generate Android code in third-party/some-library/android/generated.
shell
npx @react-native-community/cli codegen \
    --path third-party/some-library \
    --platform android \
    --outputPath third-party/some-library/android/generated

Including Generated Code into Libraries
The Codegen CLI is a great tool for library developers. It can be used to take a sneak-peek at the generated code to see which interfaces you need to implement.
Normally the generated code is not included in the library, and the app that uses the library is responsible for running the Codegen at build time. This is a good setup for most cases, but Codegen also offers a mechanism to include the generated code in the library itself via the includesGeneratedCode property.
It's important to understand what are the implications of using includesGeneratedCode = true. Including the generated code comes with several benefits such as:
•	No need to rely on the app to run Codegen for you, the generated code is always there.
•	The implementation files are always consistent with the generated interfaces (this makes your library code more resilient against API changes in codegen).
•	No need to include two sets of files to support both architectures on Android. You can only keep the New Architecture one, and it is guaranteed to be backwards compatible.
•	Since all native code is there, it is possible to ship the native part of the library as a prebuild.
On the other hand, you also need to be aware of one drawback:
•	The generated code will use the React Native version defined inside your library. So if your library is shipping with React Native 0.76, the generated code will be based on that version. This could mean that the generated code is not compatible with apps using previous React Native version used by the app (e.g. an App running on React Native 0.75).
Enabling includesGeneratedCode
To enable this setup:
•	Add the includesGeneratedCode property into your library's codegenConfig field in the package.json file. Set its value to true.
•	Run Codegen locally with the codegen CLI.
•	Update your package.json to include the generated code.
•	Update your podspec to include the generated code. (for ios only)
•	Update your build.Gradle file to include the generated code.
•	Update cmakeListsPath in react-native.config.js so that Gradle doesn't look for CMakeLists file in the build directory but instead in your outputDir.

